Propuesta Definitiva de Arquitectura y Flujo de Trabajo: PerfectOCR-Vectorial
1. Visión General
Se implementará una arquitectura de procesamiento vectorial que traduce los polígonos del OCR en un sistema de vectores y perfiles ricos en información. El sistema prioriza el ordenamiento geométrico para luego calcular atributos morfológicos basados en un mapa de densidad de caracteres predefinido, permitiendo análisis de alta precisión tanto a nivel de tabla como de documento.
2. Estructura de Módulos y Datos
La estructura de directorios propuesta se mantiene, pero la función de cada módulo se define ahora con total precisión.
data/density/char_density_map.txt: (Renombrado de conversor_embidingtxt.txt) El archivo que contiene el mapeo carácter -> densidad (z_i).
core/vectorization/density_mapper.py: Un componente de servicio (singleton o clase inyectada) que carga char_density_map.txt al inicio. Proporcionará dos métodos esenciales:
get_density(char: str) -> int: Devuelve el z_i para un carácter.
get_char_type(char: str) -> str: Devuelve 'a', 'n', o 'e' basado en el rango de densidad del carácter.
core/vectorization/data_models.py: Define las dataclasses para VectorElemental, PerfilMorfologico, VectorDiferenciador, LineaVectorizada, etc.
3. Flujo de Trabajo Detallado y Explícito
Fase 1: Construcción de Líneas (Inalterada)
El DerivativeGrouper ordena y agrupa los polígonos en líneas (S_k) basándose en la geometría (y, x) y las derivadas.
Salida: List[List[PolygonOCR]].
Fase 2: Vectorización y Perfilado (Proceso Clave Refinado)
El VectorizationCoordinator orquesta esta fase: Itera sobre cada línea S_k y cada PolygonOCR dentro de ella.
Para cada Polígono, el elemental_vectorizer hace lo siguiente:
Recibe el polígono (ej: texto "Total:").
Utiliza el DensityMapper para procesar el texto carácter por carácter:
Construye la cadena del PerfilMorfologico: "aaaaae".
ii. Suma las densidades individuales (z_i) de cada carácter.
A partir de la cadena del perfil ("aaaaae"), calcula:
l_c (longitud total), l_a (conteo de 'a'), l_n, l_e.
r_a (ratio de 'a'), r_n, r_e.
Calcula la densidad media: z_m = suma_de_z_i / l_c.
Ensambla el VectorElemental (V_e) con todos los escalares geométricos (x, y, h_x, k...) Y los escalares morfológicos recién calculados (l_c, r_a, z_m...).
Crea el objeto PerfilMorfologico que contiene únicamente la cadena "aaaaae" y un ID para vincularlo al polígono.
Para cada Línea (S_k), se ejecutan dos procesos en paralelo:
El atomic_vectorizer:
Concatena el texto de todos los polígonos de la línea sin espacios (ej: "Total:$109.50").
ii. Itera sobre esta cadena pura, carácter por carácter. Para cada uno:
iii. Obtiene su densidad z_i del DensityMapper.
iv. Le asigna un índice secuencial x_ri (empezando en 1).
Construye el VectorAtómico (V_ar) como una lista de tuplas: [(1, 71), (2, 109), ..., (13, 0)].
El differential_vectorizer:
Calcula las estadísticas agregadas de la geometría de la línea (Y_skmin, Y_skmax, O_sk...).
ii. Ensambla el VectorDiferenciador (V_sk).
Fase 3 y 4: Análisis y Post-Procesamiento (Roles Clarificados)
Detección de Tabla (DtwTableDetector): Usa una versión simplificada del V_ar de cada línea (el V_dtw, que es solo la secuencia de z_i) para encontrar el bloque de la tabla.
División de Columnas (SlidingWindowDivider): Aplica el método de la ventana deslizante sobre el "Vector Atómico Enriquecido" de las líneas de la tabla. Este análisis es letra por letra y su objetivo es encontrar los límites de las columnas.
Análisis Semántico (PostprocessingCoordinator): Utiliza el "Vector Elemental Enriquecido (V_er)". Compara los V_er de diferentes palabras para entender su rol en el documento (ej: diferenciar los "TOTALES"). Este análisis es a nivel de palabra, no de letra.
