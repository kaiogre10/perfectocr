Específicaiones: 

x_n < x_n+1
x_n-1 > x_n

Solamente se puede asumir que hay una tabla y la tenemos que encontrar.
Para que algo se pueda asegurar/afirmar debe de haber evidencia matemática contundente.
La tabla de densidad, y clasificación de las palabras, mostrada aquí es solamente ilustrativa para comprensión del lector, la real está anexa en "conversor_embiding.txt".
Caracter, densidad
Números: (N)
Caracteres especiales: (E)
Alfábeticas (A)
Estos también son los 3 tipos de caracteres.
Se distingue perfectamente entre mayúsculas, minúsculas, acentos, etc... Los caracteres de espaciado no son válidos ni tomados en cuenta.
c{n, e, a}

Clasificación semántica (CL_c) de los polígonos/letras:
numeric: números asociados a cantidades y dinero, no admiten letras ni especiales salvo "$", ".", densidad esperada baja, si "$" existe hay una alta probabilidad de que "." también apareza lo que confirma que no es parte de una descripción.
	Si aparece "/" o "-" entonces es probable que sea "date".
mixed: texto en general, admite cualquier tipo de carácter y palabra, densidad esperada alta.
code: identificadores como sku, upc, ean, etc... una combinación generalmente consistente entre números y mayúsculas, >3 caracteres densidad = en un intervalo esperado 15-50
date: prácticamente idéntica a mixed, la diferencia es el método de clasificación por signature/regex y por densidad = existencía de "/" o "-" es fuerte indicio, l_n siempre par
rfc: Patrón más sencillo de identificar: aparición de "RFC" (en cualquiera de sus variantes) asegura la aparición de la combinación que busco "XXXX000000(combinación aleatoria entre números o letras), no admite especiales.
total: Esta palabra suele aparecer en diferentes lugares, lo que le da la semántica y significado es su contexto. Suelen tener un 'k' pequeño, con un numeric a la derecha (puede haber más palabras mixed entre ellos pero)::
	Los monetarios (total_mtl) suelen tener una z_m y l_n relativa superior (o sea con respecto a todas las demás numéric)
	Mientas que los totales referentes a la cantidad de artículos (total_c) suelen tener una z_m inferior al total_mtl, y l_n promedio.

Flujo de trabajo y proceso de vectorizado:

Una vez entregado el texto de ocr corregido y limpio, recibiremos un polígono con GEO, c_ocr en un diccionario:
	Polígono: (x, y, v, c_ocr, texto)
	1) x: coordenada geométrica.
	2) y: coordenada geométrica.
	3) v: vertices del polígono 
	4) c_ocr: confianza dada por el motor OCR

Reduciremos todos los polígonos a su patrón morfológico más simple, clasificados en su CL_c:
Para cada V_a, si x_ri pertenece a [0-9], [10-55] o [56-116] entonces pertenece a CL{N, E, A} respectivamente.

Ejemplo de clasificación semántica por palabra por medio del tipo de carácter que conforma cada polígono incluso si están mal agrupadas

Total: $109.50
T, o, t, a, l, :, $, 1, 0, 9, ., 5, 0 --> 13 caracteres.
a, a, a, a, a, e, e, n, n, n, e, n, n --> 5a, 3e, 5n; (38%a, 23%e, 38%n); reducción morfológica
71, 109, 106, 114, 105, 46, 12, 1, 0, 9, 10, 5, 0; Densidad=45.23

$109.50
$, 1, 0, 9, ., 5, 0 --> 7 caracteres.
e, n, n, n, e, n, n --> 0a, 2e, 5n; (0%a, 29%e, 71%n); reducción morfológica
12, 1, 0, 9, 10, 5, 0; Densidad= 5.2

Total:
T, o, t, a, l, : --> 6 caracteres
a, a, a, a, a, e --> 5a, 1e, 0n; (83%a, 17%e, 0%n); reducción morfológica
71, 109, 106, 114, 105, 46; Densidad=91.83

Esta reducción morfológica no será indexada al vector, solamente será usada para generar los escalares.

Se inicia la generación de datos a partir de la información obtenida:
Datos obtenidos:

5) l_c: cantidad de caractéres.
6) x_min: limite horizontal inferior del polígono.
7) x_max: limite horizontal superior del polígono.
8) y_min: limite vertical inferior del polígono.
9) y_max: limite vertical superior del polígono.
10) l_a: cantidad de caracteres alfabéticos.
11) l_n: cantidad de caracteres numéricos.
12) l_e: cantidad de caracteres especiales.
13) r_a: ratio de proporción de caracteres alfabéticas.
14) r_n: ratio de proporción de caracteres numéricos.
15) r_e: ratio de proporción de caracteres especiales.
16) z_m: promedio de densidad entre todos sus elementos.

Para generar los vectores atómico y diferenciador es necesario agrupar en subconjuntos S_k los polígonos.
Los polígonos se agrupan según su estabilidad vertical (eje y) de sus centroides , en el plano R2, sin importar.
Para medir esta estabilidad y poder agrupar los polígonos correctamente calcularemos directamente la derivada del arcotangente y/x (d_arctan) y arcocontangente x/y (arccot) de los ángulos generados ortogonalmente por el centroide y el origen.
Ordenamos los polígonos en orden ascendente en por y_i
Los cambios bruscos en estas derivadas indican el desplazamiento lineal de sus elementos, y "saltos" entre líneas. Cada cambio brusco en la derivada del arcocotangente indica si un elemento pertenece a S_k o S_k+1.
El orden de los S_k es automático debido al ordenamiento y proceso anterior. 
Una vez agrupados los polígonos en sus S_k respectivos hacemos un ordenamiento interno lógico por sus x_i en orden ascendente (a la derecha).
En este punto ya habremos generado los siguientes datos:
17) d_arccot
18) d_arctan

Ya ordenados los polígonos:
	A) Generamos los datos restantes para el vector elemental:
		19) h_x: distancia horizontal con el polígono inmediato con los límites x_max y x_min, en dirección x creciente (A la derecha)
		20) O_x: distancia ortogonal al eje x respecto de y_min.
		21) k: número correspondiente al S_k, es el identificador y además respresenta el ordenamiento vertical entre todos los S_k.
	
	B) Generamos el vector atómico: V_a[x_ri, z_i]
		22) x_ri: posición horizontal relativa ordenada de cada unidad básica de todos los polígonos ordenados en S_k.
		23) z_i: densidad individual de cada unidad básica que constituye al polígono dada por una escala de densidad ponderada arbitrariamente.

Procedemos con la vectorización del polígono para generar el vector elemental con la siguiente forma:

Vector elemental: V_e[x, y, v, l_c, x_max, x_min, y_max, y_min, c_ocr, l_a, l_n, l_e, r_a, r_n, r_e, z_m, d_arctan, d_arccot, h_x, o_x, k]
Para cada polígono*

Enriquecemos el vector atómico con el vector elemental:
Vector atómico enriquecido: V_ar[x_ri, z_i, V_e]
		Forma completa: V_ar[x_ri, z_i, x, y, v, l_n, x_max, x_min, y_max, y_min, c_ocr, l_a, l_n, l_e, r_a, r_n, r_e, z_m, d_arctan, d_arccot, h_x, o_x, k]
		Los escalares son heredados homogéneamente a cada vector unitario.

Para detección tabular crearemos el Vector DTW: V_dtw[z_1, z_2, ..., z_n+1]
	Aplicar a cada S_k
	Aplicar una transformación lineal a todos los V_a contenidos en S_k
	Ya que k = numero escalar que sirve para diferenciar a que S_k pertenece un polígono o unidad básica.
	Vectorizamos V_k[V_a1, V_a2, ..., V_an] -> V_k[(x_r1, z_1), (x_r2, z_2), ..., (x_ri, z_i)]
	Mapeamos las coordenadas a una secuencia indexada:
	(x_ri, z_i) -> z_n
		z_n: Preserva el orden secuencial dado por x_ri, transforma los datos para que el método de detección tabular pueda interpretarlos correctamente.

El siguiente paso es integrar los datos par dar forma al vector diferenciador:

24) Y_skmin: valor promedio de los y_min de todos los polígonos.
25) Y_skmax: valor promedio de los y_max de todos los polígonos.
26) X_skmin: valor x_min mínimo, más cercano a 0.
27) X_skmax: valor x_max máximo, más alejado de 0.
28) O_xm: distancia ortogonal al eje x respecto de y_skmin.
29) O_sk: distancia entre el y_skmax y el y_skmin del S_n+1 .

Forma del vector diferenciador: V_sk[Y_min, Y_max, X_min, X_max, O_xm, O_sk]
	Vector diferenciador forma completa: V_sk[Y_min, Y_max, X_min, X_max, O_xm, O_sk]

Enriquecemos el V_e para dar paso al vector elemental enriquecido: V_er[V_e, V_sk, V_a]
	Forma completa del vector elemental enriquecido: V_e[x, y, v, l_c, x_max, x_min, y_max, y_min, c_ocr, l_a, l_n, l_e, r_a, r_n, r_e, z_m, d_arctan, d_arccot, h_x, o_x, k, x_ri, z_i, Y_min, Y_max, X_min, X_max, O_x]

Detección de tablas:
Para cada V_dtw aplicar método estadístico de detección de patrones DTW.
Una vez detectadas las filas, tomar el intervalo entre las filas V_dtwmax y V_dtwmin que presenten un patrón de densidad similar.
Definir este intervalo como la tabla interna. 

Asignación a columnas de los valores tabulares:
Comparar explícitamente los V_dtw comprendidos entre V_dtwmax & V_dtwmin con sus valores escalares k respectivos para identificar la tabla.
Para cada V_ar con k = k, aplicar la función de similitud coseno por el método de la ventana impar.

Rastreo de datos no tabulares y clasificación semántica:

Buscar por Regex simple buscaremos los patrones morfológicos y textuales para extraer los datos que necesitamos:

date -> Números: n{2,4}ea{2,10}en{2,4}, nnennenn
	Patrones textuales más comunes (polígonos):
		[66, 69, 80, 63, 81]; Densidad = 72 
		[66, 114, 107, 96, 114]; Densidad = 99 

rfc -> aaaan{5, 6}, [na]{3}

Totales -> total_mtl: e?n{1,}e?(nn)
	   total_c: (n{1, 4})?
           Patrones textuales más comunes (polígonos):
		[71, 109, 106, 114, 105]; Densidad = 105
		[71, 64, 71, 81, 67]; Densidad = 71

Los patrones de densidad admiten una variación del 5% en sus densidades*

Una vez encontrados los patrones morfológicos y los polígonos por densidas usar la función de relación coseno entre los patrones morfológicos y textuales usando el V_er, así se asgura encontrar las palabras y sus valores requeridos sin importar el ruido o palabaras intermedias. El uso del V_er está diseñado de manera que podemos derteminar si están relacionados o no. Así como podemos distinguir "ciegamente" si exacatamente la misma palabra significa cosas diferentes dependiendo de su posición textual.
