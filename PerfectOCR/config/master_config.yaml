# PerfectOCR/config/master_config.yaml
workflow:
  input_folder: "C:/PerfectOCR/input"
  output_folder: "C:/PerfectOCR/output"
  temp_folder: "C:/PerfectOCR/data/temp"
  log_level: "DEBUG" # DEBUG, INFO, WARNING, ERROR, CRITICAL
  project_root: ".." 
  aggregated_tables_default_name: "all_tables_summary.txt"
  generate_pure_text_file: false # For lineal_coordinator output
  # NUEVA CONFIGURACIÓN PARA MI i5-8400H
  max_workers: 6  # 8 hilos - 2 reservados = 6 óptimo

enhancement_service_api:
  enabled: false
  # La IP de tu Inspiron en la red local.
  url: "http://192.168.0.11:8001/preprocess" 

  # Debe ser idéntico al que está en el main_api.py de la Inspiron.
  api_hash: "95ae9d4fbf2b668a2b0d79891d1a44417dc8ba355b74b8bd16e60cb93f322177"
  
  # Tiempo máximo de espera para la respuesta de la API en segundos.
  timeout_seconds: 120


image_preparation:
  quality_assessment_rules:
    deskew:
      min_angle_for_correction: 0.1
      canny_thresholds: [50, 150]
      hough_threshold: 150
      hough_min_line_length_cap_px: 300
      hough_max_line_gap_px: 20
      hough_angle_filter_range_degrees: [-20.0, 20.0]
    # REGLAS DIFERENCIADAS: Cada motor tiene su propio conjunto de reglas.
    tesseract:
      denoise:
        sharpness_thresholds: [60.0, 120.0]
        strengths_map: [7, 5, 3] # Menos agresivo para Tesseract
      contrast_enhancement:
        clahe_clip_limit: 1.2
        dimension_thresholds_px: [1000, 2500]
        grid_sizes_map: [[8, 8], [10, 10], [12, 12]]
      binarization:
        adaptive_c_value: 7
        height_thresholds_px: [800, 1500, 2500]
        block_sizes_map: [31, 41, 51, 61] # Bloques más grandes para Tesseract

    paddleocr:
      denoise:
        sharpness_thresholds: [50.0, 100.0]
        strengths_map: [12, 7, 5] # Más agresivo para Paddle
      contrast_enhancement:
        clahe_clip_limit: 2.0
        dimension_thresholds_px: [1000, 2500]
        grid_sizes_map: [[6, 6], [8, 8], [10, 10]]
      binarization:
        adaptive_c_value: 7
        height_thresholds_px: [800, 1500, 2500]
        block_sizes_map: [21, 25, 35, 41]
        
    # NUEVA SECCIÓN PARA EL ANALIZADOR ESPACIAL
    spatial_analysis:
      denoise:
        sharpness_thresholds: [50.0, 100.0]
        strengths_map: [5, 3, 1] # Denoise muy suave para no romper líneas
      contrast_enhancement:
        clahe_clip_limit: 1.0
        dimension_thresholds_px: [1000, 2500]
        grid_sizes_map: [[8, 8], [10, 10], [12, 12]]
      binarization:
        # Parámetros para hacer las líneas estructurales lo más sólidas posibles
        adaptive_c_value: 5
        height_thresholds_px: [800, 1500, 2500]
        # Bloques más pequeños para capturar detalles finos de las líneas
        block_sizes_map: [15, 21, 25, 31]

spatial_analyzer:
  optimization:
    max_workers: 2                    # Máximo 2 hilos para análisis espacial
    use_integral_image: true          # Para ventanas de densidad grandes
    use_scharr_gradients: true        # Operador Scharr más preciso
    enable_caching: true              # Cache de resultados intermedios
    cache_size_mb: 100               # Tamaño máximo de cache
  
  performance:
    density_map_window_size: 23       # Mantener calidad
    gradient_threshold_multiplier: 1.5 # Mantener precisión

  # MODO SENCILLO → Solo detectar las líneas horizontales que generan ruido.
  ocr_noise_filtering:
    enabled: true
    method: gradient   # Detector basado solo en gradiente

    # --- PARÁMETROS MÍNIMOS NECESARIOS ---
    gradient_percentile_threshold: 95.0  # Sensibilidad (porcentil superior)
    min_line_length_ratio: 0.05          # Descarta trazos demasiado cortos
    expansion_factor: 3.0               # Cuánto expandir la máscara verticalmente

  # (Se eliminó table_region_validation_rules: ahora no se requiere)

ocr:
  default_folder_origin: "unknown_mode" # For metadata if not otherwise specified
  default_image_pil_mode: "unknown_mode"  # For metadata if not otherwise specified
  tesseract:
    cmd_path: "C:/Program Files/Tesseract-OCR/tesseract.exe"
    lang: "spa+eng"
    # PSM 6: Asume un único bloque de texto uniforme. Es más flexible que 4.
    psm: 6
    oem: 3  # Default auto-switch (usa LSTM, el mejor motor)
    dpi: 300
    preserve_interword_spaces: 1
    # Umbral de confianza más bajo para no descartar palabras en imágenes difíciles.
    # El análisis posterior puede filtrarlas si es necesario.
    confidence_threshold: 15.0
    tessedit_char_whitelist: ""  # Sin filtros para permitir todos los caracteres
    user_words_path: null # Path to a user words file, or null
    
  paddleocr:
    use_angle_cls: true
    lang: "es"
    det_model_dir: "C:/PerfectOCR/models/paddle/det/es"
    rec_model_dir: "C:/PerfectOCR/models/paddle/rec/es"
    cls_model_dir: "C:/PerfectOCR/models/paddle/cls"
    use_gpu: false
    show_log: false

table_extractor:
  # PARÁMETROS PARA RECONSTRUCCIÓN DE LÍNEAS
  line_reconstructor_params:
    vertical_overlap_threshold: 0.4
  
  header_detector_config:
    table_header_keywords_list:
      semantic_keywords_path: "config/semantic_keywords.yaml"

    table_end_keywords: [ 
        "TOTAL", "SUBTOTAL", "SUMA TOTAL", "OBSERVACIONES", "VALOR TOTAL",
        "GRACIAS POR SU COMPRA", "PAGO CON", "EFECTIVO", "CAMBIO",
        "NO, DE ARTICULOS", "NO. DE ARTICULOS", "TOTAL DE ARTICULOS",
        "FIRMA", "AUTORIZADO POR", 'NO. DE ARTICULOS:',
        
        # Nuevas variaciones de TOTAL
        "TOTAL A PAGAR", "TOTAL PAGADO", "TOTAL DE LA COMPRA",
        "TOTAL DE VENTA", "TOTAL DE ARTÍCULOS", "TOTAL DE ITEMS",
        "TOTAL DE PRODUCTOS", "TOTAL DE MERCANCÍA",
        "TOTAL DE LA TRANSACCIÓN", "TOTAL DE LA OPERACIÓN",
        
        # Palabras clave de cierre de ticket
        "GRACIAS POR SU PREFERENCIA", "VUELVA PRONTO",
        "ATENDIDO POR", "CAJERO", "FECHA DE EMISIÓN",
        "HORA DE EMISIÓN", "FOLIO", "TICKET", "RECIBO",
        
        # Palabras clave de pago
        "PAGO EN EFECTIVO", "PAGO CON TARJETA",
        "PAGO CON TRANSFERENCIA", "MONTO RECIBIDO",
        "DEVOLUCIÓN"
      ]
      
    header_detection_fuzzy_min_ratio: 85.0
    header_min_y_ratio: 0.05 # Min Y position of header relative to page height (0.0-1.0)
    header_max_y_ratio: 0.75 # Max Y position of header relative to page height (0.0-1.0)
    min_header_keywords_in_line: 2
    max_header_keywords_in_line: 5
    max_header_line_gap_factor: 2.50 # Multiplier of avg line height for max gap between header lines
    min_line_confidence_for_header: 70.00 # Min avg confidence of a line to be considered header
    default_line_height_for_gap: 20.00 # Fallback if dynamic line height can't be computed

  geometric_structurer_config:
    {}

  max_validation_config:
    enabled: true
    quantitative_whitelist: ["N/A", "S/D", "-", "", "n/a", "N.A.", "0", "0.00"]
    reassignment_enabled: true
    max_vertical_distance_for_reassignment: 30.0

postprocessing:
  text_correction:
    enabled: false
    vocab_path: "data/dictionaries/es_MX.txt"
    min_confidence_spell: 85.0
    # For common_errors and contextual_correction, lambdas are hard to define in YAML.
    # Python code will implement the lambda logic, YAML can enable/disable them or provide simple string patterns.
    apply_common_error_correction_rules_defined_in_code: true # Enable/disable hardcoded common error rules
    apply_contextual_correction_rules_defined_in_code: false # Enable/disable hardcoded contextual rules
    # Example of how simple rules could be defined if needed, but complex ones stay in code:
    # simple_common_errors:
    #   - pattern: "erron"
    #     replacement: "error"
    # contextual_rules_enabled: true # To enable/disable this step
    # contextual_correction_rules:
    #    - pattern: '\b(cliente|proveedor)\b'
    #      expected_context_keywords: ['nombre', 'dirección', 'teléfono']
    #      flags: "IGNORECASE"

  text_formatting:
    format_dates: false
    normalize_numbers: false
    max_line_length_for_preserve_breaks: 80
    # Date patterns are complex for pure YAML; Python can store them and YAML can enable/disable categories
    apply_date_normalization_rules_defined_in_code: true
    # month_names_map: # For date normalization if lambda_month_name_to_num_date is used
    #   enero: '01'
    #   # ...
    #   diciembre: '12'
    #   default_month_num: '00'

output_config:
  enabled_outputs:
    ocr_raw: false
    reconstructed_lines: false
    structured_table: false
    semantically_corrected_matrix: true
    visual_output: false

batch_processing:
  small_batch_limit: 5
  max_physical_cores: 4
  add_extra_worker: true
  batch_size_factor: 2
  auto_mode: true